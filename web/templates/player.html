<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live: {{.Key}}</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0b;
            --bg-secondary: #141416;
            --bg-tertiary: #1c1c1f;
            --accent: #ff3d3d;
            --accent-glow: rgba(255, 61, 61, 0.3);
            --text-primary: #ffffff;
            --text-secondary: #a0a0a5;
            --text-muted: #5c5c62;
            --border: #2a2a2e;
            --success: #22c55e;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 2rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s;
        }

        .back-btn:hover {
            color: var(--text-primary);
        }

        .stream-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .live-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--accent);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 0 20px var(--accent-glow);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        .live-badge.offline {
            background: var(--text-muted);
            box-shadow: none;
            animation: none;
        }

        .live-dot {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px var(--accent-glow); }
            50% { box-shadow: 0 0 30px var(--accent-glow), 0 0 40px var(--accent-glow); }
        }

        /* Main Content */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            gap: 1.5rem;
        }

        /* Video Container */
        .video-container {
            position: relative;
            width: 100%;
            max-width: 1200px;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
        }

        .video-wrapper {
            position: relative;
            padding-top: 56.25%; /* 16:9 */
            background: #000;
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* Video Overlay */
        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .video-container:hover .video-overlay {
            opacity: 1;
        }

        .overlay-live {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--accent);
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            pointer-events: auto;
        }

        .overlay-live.synced {
            background: var(--success);
        }

        /* Controls Bar */
        .controls-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border);
        }

        .controls-left, .controls-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .control-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.6rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: var(--border);
            color: var(--text-primary);
        }

        .control-btn.live-btn {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .control-btn.live-btn:hover {
            background: #ff5555;
        }

        .control-btn.live-btn.synced {
            background: var(--success);
            border-color: var(--success);
        }

        .latency-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-muted);
            background: var(--bg-secondary);
            padding: 0.5rem 0.8rem;
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        .latency-display span {
            color: var(--success);
        }

        /* Status Messages */
        .status-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            gap: 1rem;
        }

        .status-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-text {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .error-icon {
            font-size: 3rem;
        }

        /* Info Section */
        .info-section {
            width: 100%;
            max-width: 1200px;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .info-card {
            flex: 1;
            min-width: 250px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem 1.25rem;
        }

        .info-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .info-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
            word-break: break-all;
        }

        .info-value.copyable {
            cursor: pointer;
            transition: color 0.2s;
        }

        .info-value.copyable:hover {
            color: var(--accent);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <a href="/" class="back-btn">
                <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                </svg>
                Dashboard
            </a>
            <div class="stream-title">{{.Key}}</div>
        </div>
        <div id="headerBadge" class="live-badge">
            <span class="live-dot"></span>
            LIVE
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Video Player -->
        <div class="video-container">
            <div class="video-wrapper">
                <video id="video" playsinline></video>
                
                <!-- Loading/Error Overlay -->
                <div id="statusOverlay" class="status-overlay">
                    <div class="spinner"></div>
                    <div class="status-text">Connecting to live stream...</div>
                </div>

                <!-- Video Overlay (shows on hover) -->
                <div class="video-overlay">
                    <div id="overlayLive" class="overlay-live">
                        <span class="live-dot"></span>
                        LIVE
                    </div>
                </div>
            </div>

            <!-- Controls Bar -->
            <div class="controls-bar">
                <div class="controls-left">
                    <button id="liveBtn" class="control-btn live-btn" onclick="jumpToLive()">
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="8"/>
                        </svg>
                        Jump to Live
                    </button>
                    <button class="control-btn" onclick="toggleMute()">
                        <svg id="muteIcon" width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"/>
                        </svg>
                        <span id="muteText">Unmute</span>
                    </button>
                    <button class="control-btn" onclick="toggleFullscreen()">
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/>
                        </svg>
                        Fullscreen
                    </button>
                </div>
                <div class="controls-right">
                    <div id="latencyDisplay" class="latency-display">
                        Latency: <span>--</span>s
                    </div>
                </div>
            </div>
        </div>

        <!-- Info Cards -->
        <div class="info-section">
            <div class="info-card">
                <div class="info-label">RTMP Ingest URL</div>
                <div class="info-value copyable" onclick="copyToClipboard('rtmp://{{.Host}}:1935/live/{{.Key}}')">
                    rtmp://{{.Host}}:1935/live/{{.Key}}
                </div>
            </div>
            <div class="info-card">
                <div class="info-label">HLS Playback URL</div>
                <div class="info-value copyable" onclick="copyToClipboard(window.location.origin + '/static/hls/{{.Key}}/index.m3u8')">
                    /static/hls/{{.Key}}/index.m3u8
                </div>
            </div>
        </div>
    </main>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <script>
        const video = document.getElementById('video');
        const statusOverlay = document.getElementById('statusOverlay');
        const latencyDisplay = document.getElementById('latencyDisplay');
        const liveBtn = document.getElementById('liveBtn');
        const overlayLive = document.getElementById('overlayLive');
        const headerBadge = document.getElementById('headerBadge');
        const videoSrc = '/static/hls/{{.Key}}/index.m3u8';
        const metadataSrc = '/static/hls/{{.Key}}/stream.json';
        
        let hls = null;
        let isAtLiveEdge = true;
        let isLiveStream = true; // true = live, false = VOD (has ENDLIST)
        let manifestLoadAttempts = 0;
        let retryTimeout = null;
        let latencyInterval = null;

        // Update badge based on stream state
        function updateBadge(state) {
            headerBadge.classList.remove('offline');
            switch(state) {
                case 'live':
                    headerBadge.innerHTML = '<span class="live-dot"></span> LIVE';
                    break;
                case 'vod':
                    headerBadge.classList.add('offline');
                    headerBadge.innerHTML = 'RECORDED';
                    break;
                case 'offline':
                    headerBadge.classList.add('offline');
                    headerBadge.innerHTML = '<span class="live-dot"></span> OFFLINE';
                    break;
                case 'loading':
                    headerBadge.innerHTML = '<span class="live-dot"></span> LOADING';
                    break;
            }
        }

        function initPlayer() {
            // Immediately try to load HLS - don't wait for metadata
            showStatus('loading', 'Connecting...');
            updateBadge('loading');
            startHlsPlayer();
        }

        function startHlsPlayer() {
            if (hls) {
                hls.destroy();
                hls = null;
            }

            if (retryTimeout) {
                clearTimeout(retryTimeout);
                retryTimeout = null;
            }

            if (Hls.isSupported()) {
                hls = new Hls({
                    debug: false,
                    enableWorker: true,
                    
                    // Aggressive fast-start settings
                    lowLatencyMode: true,
                    backBufferLength: 30,
                    
                    // Live stream tuning - start fast
                    liveSyncDurationCount: 2,      // Sync to 2 segments behind live edge
                    liveMaxLatencyDurationCount: 4, // Max 4 segments behind before force sync
                    liveDurationInfinity: true,
                    
                    // Minimal buffering for fast start
                    maxBufferLength: 10,
                    maxMaxBufferLength: 30,
                    maxBufferSize: 30 * 1000 * 1000, // 30MB
                    maxBufferHole: 0.5,
                    
                    // Start at end (live edge)
                    startPosition: -1,
                    
                    // Fast manifest loading
                    manifestLoadingTimeOut: 5000,
                    manifestLoadingMaxRetry: 2,
                    manifestLoadingRetryDelay: 500,
                    
                    // Fast fragment loading  
                    fragLoadingTimeOut: 10000,
                    fragLoadingMaxRetry: 3,
                    fragLoadingRetryDelay: 500,
                    
                    // Level loading
                    levelLoadingTimeOut: 5000,
                    levelLoadingMaxRetry: 2,
                    levelLoadingRetryDelay: 500,
                    
                    // Enable ABR for smooth playback
                    abrEwmaDefaultEstimate: 1000000,
                    startLevel: -1, // Auto-select quality
                });

                // Add cache buster to avoid stale manifest
                const srcWithCacheBust = videoSrc + '?_=' + Date.now();
                hls.loadSource(srcWithCacheBust);
                hls.attachMedia(video);

                // Track if we got any data
                let gotManifest = false;
                let gotFragment = false;

                hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
                    console.log('Manifest parsed:', data.levels.length, 'levels');
                    gotManifest = true;
                    manifestLoadAttempts = 0;
                    
                    // Check if this is a live stream or VOD
                    isLiveStream = hls.levels[0]?.details?.live ?? true;
                    
                    if (isLiveStream) {
                        updateBadge('live');
                    } else {
                        updateBadge('vod');
                    }
                });

                hls.on(Hls.Events.FRAG_LOADED, () => {
                    if (!gotFragment) {
                        gotFragment = true;
                        console.log('First fragment loaded - starting playback');
                        statusOverlay.classList.add('hidden');
                        
                        // Jump to live edge for live streams
                        if (isLiveStream) {
                            jumpToLive();
                        }
                        
                        video.play().catch((e) => {
                            console.log('Autoplay blocked:', e);
                            showPlayButton();
                        });
                    }
                });

                hls.on(Hls.Events.LEVEL_LOADED, (event, data) => {
                    isLiveStream = data.details.live;
                    if (isLiveStream) {
                        updateBadge('live');
                    } else {
                        updateBadge('vod');
                    }
                });

                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.log('HLS Error:', data.type, data.details, data.fatal);
                    
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                handleNetworkError(data);
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log('Attempting media error recovery...');
                                hls.recoverMediaError();
                                break;
                            default:
                                handleFatalError();
                                break;
                        }
                    } else if (data.details === Hls.ErrorDetails.BUFFER_STALLED_ERROR) {
                        // Non-fatal buffer stall - try to recover
                        console.log('Buffer stalled, attempting recovery...');
                        if (isLiveStream && hls.liveSyncPosition) {
                            video.currentTime = hls.liveSyncPosition;
                        }
                    }
                });

                // Start latency monitoring
                if (latencyInterval) clearInterval(latencyInterval);
                latencyInterval = setInterval(updateLatency, 500);

            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Safari native HLS - simpler handling
                video.src = videoSrc + '?_=' + Date.now();
                
                video.addEventListener('loadedmetadata', () => {
                    statusOverlay.classList.add('hidden');
                    updateBadge('live');
                    // Seek near end for live
                    if (video.duration && isFinite(video.duration)) {
                        video.currentTime = Math.max(0, video.duration - 2);
                    }
                    video.play().catch(() => showPlayButton());
                }, { once: true });

                video.addEventListener('error', () => {
                    handleFatalError();
                });
            } else {
                showStatus('error', 'HLS not supported in this browser');
            }
        }

        function handleNetworkError(data) {
            manifestLoadAttempts++;
            console.log('Network error, attempt:', manifestLoadAttempts);
            
            if (manifestLoadAttempts >= 5) {
                // Give up after 5 attempts
                showStatus('waiting', 'Stream not available');
                updateBadge('offline');
                
                // Keep trying in background
                retryTimeout = setTimeout(() => {
                    manifestLoadAttempts = 0;
                    startHlsPlayer();
                }, 5000);
            } else {
                // Quick retry
                showStatus('loading', 'Reconnecting...');
                retryTimeout = setTimeout(() => {
                    if (hls) {
                        // Just reload the source
                        hls.loadSource(videoSrc + '?_=' + Date.now());
                    } else {
                        startHlsPlayer();
                    }
                }, 1000);
            }
        }

        function handleFatalError() {
            showStatus('error', 'Playback error');
            updateBadge('offline');
            
            retryTimeout = setTimeout(() => {
                manifestLoadAttempts = 0;
                initPlayer();
            }, 3000);
        }

        function showPlayButton() {
            statusOverlay.classList.remove('hidden');
            statusOverlay.innerHTML = `
                <button class="play-btn" onclick="forcePlay()" style="
                    width: 80px;
                    height: 80px;
                    border-radius: 50%;
                    background: var(--accent);
                    border: none;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: transform 0.2s, box-shadow 0.2s;
                    box-shadow: 0 0 30px var(--accent-glow);
                ">
                    <svg width="32" height="32" fill="white" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                </button>
                <div class="status-text" style="margin-top: 1rem;">Click to play</div>
            `;
        }

        function forcePlay() {
            statusOverlay.classList.add('hidden');
            video.muted = true;
            video.play().then(() => {
                // Unmute after a small delay
                setTimeout(() => {
                    video.muted = false;
                }, 100);
            }).catch(e => {
                console.log('Still cannot play:', e);
                // Keep muted
                video.play();
            });
        }

        function jumpToLive() {
            if (!video) return;
            
            if (hls && hls.liveSyncPosition) {
                video.currentTime = hls.liveSyncPosition;
            } else if (video.buffered && video.buffered.length > 0) {
                video.currentTime = video.buffered.end(video.buffered.length - 1) - 0.5;
            } else if (video.duration && isFinite(video.duration)) {
                video.currentTime = Math.max(0, video.duration - 1);
            }
            
            isAtLiveEdge = true;
            updateLiveIndicator();
            
            if (video.paused) {
                video.play().catch(() => {});
            }
        }

        function updateLatency() {
            if (!video || video.paused) return;

            let latency = 0;
            
            if (hls && hls.liveSyncPosition && isLiveStream) {
                latency = hls.liveSyncPosition - video.currentTime;
            } else if (video.buffered && video.buffered.length > 0) {
                const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                latency = bufferedEnd - video.currentTime;
            }

            latency = Math.max(0, latency);
            
            if (isLiveStream) {
                latencyDisplay.innerHTML = `Latency: <span>${latency.toFixed(1)}</span>s`;
                // At live edge if within 4 seconds
                isAtLiveEdge = latency < 4;
            } else {
                // For VOD, show time remaining
                const remaining = video.duration - video.currentTime;
                if (remaining > 0) {
                    const mins = Math.floor(remaining / 60);
                    const secs = Math.floor(remaining % 60);
                    latencyDisplay.innerHTML = mins > 0 
                        ? `<span>${mins}:${secs.toString().padStart(2, '0')}</span> remaining`
                        : `<span>${secs}s</span> remaining`;
                } else {
                    latencyDisplay.innerHTML = `<span>Ended</span>`;
                }
                isAtLiveEdge = false;
            }
            
            updateLiveIndicator();
        }

        function updateLiveIndicator() {
            if (!isLiveStream) {
                // VOD mode
                liveBtn.classList.remove('synced');
                liveBtn.innerHTML = `
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    Recorded
                `;
                overlayLive.innerHTML = 'RECORDED';
                overlayLive.classList.remove('synced');
                return;
            }
            
            if (isAtLiveEdge) {
                liveBtn.classList.add('synced');
                liveBtn.innerHTML = `
                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                    </svg>
                    Live
                `;
                overlayLive.classList.add('synced');
                overlayLive.innerHTML = '<span class="live-dot"></span> LIVE';
            } else {
                liveBtn.classList.remove('synced');
                liveBtn.innerHTML = `
                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="8"/>
                    </svg>
                    Jump to Live
                `;
                overlayLive.classList.remove('synced');
                overlayLive.innerHTML = '<span class="live-dot"></span> BEHIND';
            }
        }

        function showStatus(type, message) {
            const overlay = document.getElementById('statusOverlay');
            overlay.classList.remove('hidden');
            
            if (type === 'error') {
                overlay.innerHTML = `
                    <div class="error-icon">⚠️</div>
                    <div class="status-text">${message}</div>
                    <button class="control-btn" onclick="retryConnection()" style="margin-top: 1rem;">Retry Now</button>
                    <p style="color: var(--text-muted); font-size: 0.75rem; margin-top: 0.75rem;">Auto-retrying...</p>
                `;
            } else if (type === 'waiting') {
                overlay.innerHTML = `
                    <div class="spinner"></div>
                    <div class="status-text">${message}</div>
                    <button class="control-btn" onclick="retryConnection()" style="margin-top: 1rem;">Retry</button>
                    <p style="color: var(--text-muted); font-size: 0.75rem; margin-top: 0.75rem;">
                        Checking every 5 seconds...
                    </p>
                `;
            } else {
                overlay.innerHTML = `
                    <div class="spinner"></div>
                    <div class="status-text">${message}</div>
                `;
            }
        }

        function retryConnection() {
            if (retryTimeout) {
                clearTimeout(retryTimeout);
                retryTimeout = null;
            }
            
            manifestLoadAttempts = 0;
            showStatus('loading', 'Connecting...');
            updateBadge('loading');
            
            if (hls) {
                hls.destroy();
                hls = null;
            }
            
            setTimeout(startHlsPlayer, 200);
        }

        function toggleMute() {
            video.muted = !video.muted;
            const muteIcon = document.getElementById('muteIcon');
            const muteText = document.getElementById('muteText');
            
            if (video.muted) {
                muteText.textContent = 'Unmute';
                muteIcon.innerHTML = `
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"/>
                `;
            } else {
                muteText.textContent = 'Mute';
                muteIcon.innerHTML = `
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
                `;
            }
        }

        function toggleFullscreen() {
            const container = document.querySelector('.video-container');
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                container.requestFullscreen();
            }
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard!');
            });
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }

        // Track when user seeks away from live
        video.addEventListener('seeking', () => {
            if (hls && hls.liveSyncPosition && isLiveStream) {
                isAtLiveEdge = (hls.liveSyncPosition - video.currentTime) < 4;
                updateLiveIndicator();
            }
        });

        // Handle video stalls
        video.addEventListener('waiting', () => {
            if (isLiveStream && hls && video.currentTime > 0) {
                console.log('Video waiting/buffering...');
            }
        });

        // Handle video errors
        video.addEventListener('error', () => {
            console.log('Video element error:', video.error);
        });

        // Click to play (for autoplay blocked)
        video.addEventListener('click', () => {
            if (video.paused) {
                video.play().catch(() => {});
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (hls) {
                hls.destroy();
            }
            if (retryTimeout) {
                clearTimeout(retryTimeout);
            }
            if (latencyInterval) {
                clearInterval(latencyInterval);
            }
        });

        // Start immediately
        initPlayer();
    </script>
</body>
</html>
